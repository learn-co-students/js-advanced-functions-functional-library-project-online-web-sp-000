const fi = (function() {
  return {
    libraryMethod: function() {
      return 'Start by reading https://medium.com/javascript-scene/master-the-javascript-interview-what-is-functional-programming-7f218c68b3a0'
    },

    each: function(collection, callback) {
        const newArray = Object.values(collection) // Create a var and set it equal to an 'Object.value', which accepts our original array and returns the values in a new array.
        for (let i = 0; i < newArray.length; i++) { // We then use a 'for' loop to print out our messages
          callback(newArray[i]) // Using 'Object.values' ensures that we return the values if the collection is an object or an array
        }
      return collection // Finally, we return our original array after the messages have finished printing
    },

    map: function(collection, callback) {
      const emptyArray = []; // First, initialize a variable equal to an empty array. This will help keep our original array unmodified.
 
      const newArray = Object.values(collection) // Second, use 'Object.values' to again extract the values from the array

      for (let i = 0; i < newArray.length; i++){ // Third, use a 'for' loop to take each value from the array...
        emptyArray.push(callback(newArray[i])) // ...pass it into the callback AND pass the result of that callback into our empty array!
      }
      return emptyArray; // Once all values are accounted for, return the array with the modified values.
    },

    reduce: function(collection, callback, acc) {
      let total = (acc) ? acc : collection[0] // First, we check to see if an acc was entered. If so, we set it equal to our var total. Otherwise, we set total equal to the first element in our array.
      let i = (acc) ? 0 : 1 // Second, if we had an acc, we want the value of 'i' to equal 0 so that we are adding the acc to the first element of our array using the callback function. If not, we set it equal to 1 so we can add the first 2 elements of the array together.
      for (; i < collection.length; i++) { // Again, another for loop to go through each element in the collection
        total = callback(total, collection[i]) // We set our total equal to the result generated by the function, so we can keep a running tally until all elements are accounted for.
      }
      return total // Once all the elements have been added together, we return the total now equal to their sum.
    },

    find: function(collection, predicate){
        for (let i = 0; i < collection.length; i++){ // We run through our array and plug the current element into our predicate function
          if(predicate(collection[i])) { 
            return collection[i] // If the predicate returns a true value, we return that element of the collection and the for loop stops
          }
        }
        return undefined // If no element from the array returns a true value from our predicate, when the for loop ends we return 'undefined'
    },

    filter: function(collection, predicate){
      const valuesArray = [] // Set var equal to an empty array
      
      for(let i = 0; i < collection.length; i++){ // Run a for loop for each element
        if(predicate(collection[i])){ // If the element produces 'true' from our predicate function...
          valuesArray.push(collection[i]) //...push that element into the new array
        }
      }
      return valuesArray // return the array after all elements have been inspected
    },

    size: function(collection){
      const newCollection = Object.values(collection) // Again, we account for arrays and objects with 'Object.values'
      return newCollection.length // Returns the size of the array
    },

    first: function(collection, n){
      if (n){ // If the user entered a value for 'n'...
        return collection.slice(0, n) //... we take our array and slice out the first 'n' elements and return the new array
      }
        return collection[0] // Otherwise, we simply return the first element of the array (easy right? :D)
    },

    last: function(collection, n){
      if (n){ // If a 'n' was provided...
        return collection.slice(-n) // We take slice and enter in the negative value of 'n' to return the final 'n' elements
      }
      return collection[(collection.length)-1] // Otherwise, we find the last element of our array using 'length' and return it
    },

    compact: function(array){
      const newArray = []; // Create our new array to leave the original array unmodified

      for (let i = 0; i < array.length; i++){ // For look to check each element
        if (array[i]){ // If the element is a truthy value...
          newArray.push(array[i]) // Push that element into our new array
        }
      }

      return newArray // After all elements have been inspected, return the new array
    },

    sortBy: function(array, callback){
      const newArray = [...array] // Takes the original array passed in and puts it in a new array defined as 'newArray' we can now modify
      newArray.sort(function(a, b) { // We call the sort method on this array and use a function that takes two values of the array...
        return callback(a) - callback(b) //...and pass them into our callback, subtracting the values from each other and ordering them accordingly
      })
      return newArray // Finally, we return our new array with the sorted values
    },

    flatten: function(array, shallow){
      if (shallow){ // If our shallow argument has a value
        return array.flat() // We only flatten our deep array by 1 level
      }

      return array.flat(Infinity) // Otherwise, we use 'Infinity' in our flat method to flatten the array on all levels.
    },
    
    uniq: function(array, isSorted, callback){
      const newArray = [...array] // Takes our original array and makes a new one with the same values.
      if(callback) { // First we check to see if we have a callback function present...
        const modifiedArray = new Set() // Create vars that are equal to objects ready to hold values
        const originalArray = new Set()

        for(let value of newArray) { // For each value of our newArray...
          const newValue = callback(value) // we set newValue equal to the result of passing the array value into our callback function
          if(!modifiedArray.has(newValue)) { // If our modified array object does not have this callback value...
            modifiedArray.add(newValue) // We add this new value to the to the modified array object...
            originalArray.add(value) // and add the original value passed into our original array object.
          } 
        }
        return(Array.from(originalArray)) // After all the values that were the same have been removed, be return our values.
      } else if(isSorted) { // If the array is already sorted...
          return newArray.filter((value, index, array) => array.indexOf(value) === index) // we perform a filter to see if there are any duplicates
      } else {
          return newArray.filter((value, index, array) => array.indexOf(value) === index) // same here, only for unsorted arrays
      }
    },

    keys: function(object){
      return Object.keys(object) // I mean, I would explain more, but since this is so straighforward I won't ;)
    },

    values: function(object){
      return Object.values(object) // Same story here ;D
    },

    functions: function(object){
      const newArray = [] // We have our empty array defined

      for (const key in object) { //
        if(typeof object[key] === "function")
        newArray.push(object[key])
      }
      return newArray
    }
  }
})()

fi.libraryMethod()
